"""Spoiled GRE simulation sub-routines."""

__all__ = ["SPGRModel"]

from ..base import AbstractModel
from ..base import autocast

import numpy.typing as npt
import torch

from ..base import prepare_single_pool
from ..base import prepare_environmental_parameters


class SPGRModel(AbstractModel):
    r"""SPGR transverse signal at time TE after excitation.

    Parameters
    ----------
    T1 : float | npt.ArrayLike
        longitudinal exponential decay time constant (in ms).
    T2star : float | npt.ArrayLike
        effective transverse exponential decay time constant (in ms).
    TE : float | npt.ArrayLike
        echo time (in ms).
    TR : float | npt.ArrayLike
        repetition time (in ms).
    alpha : float | npt.ArrayLike
        flip angle (in deg).
    M0 : float | npt.ArrayLike
        proton density.
    field_map : float | npt.ArrayLike, optional
        B0 field map (in Hz).
    delta_cs : float | npt.ArrayLike, optional
        chemical shift of species w.r.t. the water peak (in Hz).
    diff : str | tuple[str], optional
       String or tuple of strings, saying which arguments
       to get the signal derivative with respect to.
       Defaults to ``None`` (no differentation).

    Returns
    -------
    Mxy : numpy.ndarray
        Transverse complex magnetization.

    Notes
    -----
    ``T1``, ``T2s``, ``TR``, ``TE``, ``alpha``, ``field_map`` and ``M0`` can all be
    either scalars or arrays.

    Output shape is determined by the shapes of input arrays.  All input
    arrays with equal shape will be assumed to have overlapping axes.  All
    input arrays with unique shapes will be assumed to have distinct axes
    and will be broadcast appropriately.

    Assuming a longitudinal steady-state and perfect spoiling. Note
    that dependence is on T2* rather than T2 because SE/STE formation
    is suppressed by spoiling and the signal is generated by gradient
    refocusing of an FID.

    Implements equation [14.8] from [1]_.

    References
    ----------
    .. [1] Notes from Bernstein, M. A., King, K. F., & Zhou, X. J.
           (2004). Handbook of MRI pulse sequences. Elsevier.

    """

    @autocast
    def set_properties(
        self,
        T1: float | npt.ArrayLike,
        T2star: float | npt.ArrayLike,
        M0: float | npt.ArrayLike = 1.0,
        field_map: float | npt.ArrayLike = 0.0,
        delta_cs: float | npt.ArrayLike = 0.0,
    ):
        self.properties.T1 = T1 * 1e-3
        self.properties.T2star = T2star * 1e-3
        self.properties.M0 = M0

        # We are assuming Freeman-Hill convention for off-resonance map,
        # so we need to negate to make use with this Ernst-Anderson-based implementation from Hoff
        self.properties.field_map = -2 * torch.pi * field_map
        self.properties.delta_cs = 2 * torch.pi * delta_cs

    @autocast
    def set_sequence(
        self,
        alpha: float | npt.ArrayLike,
        TR: float | npt.ArrayLike,
        TE: float | npt.ArrayLike,
    ):
        self.sequence.alpha = torch.pi * alpha / 180.0
        self.sequence.TR = TR * 1e-3  # ms -> s
        self.sequence.TE = TE * 1e-3  # ms -> s

    @staticmethod
    def _engine(
        T1: float | npt.ArrayLike,
        T2star: float | npt.ArrayLike,
        TR: float | npt.ArrayLike,
        TE: float | npt.ArrayLike,
        alpha: float | npt.ArrayLike,
        M0: float | npt.ArrayLike = 1.0,
        field_map: float | npt.ArrayLike = 0.0,
        delta_cs: float | npt.ArrayLike = 0.0,
    ):
        # Prepare relaxation parameters
        R1, R2star = 1 / T1, 1 / T2star

        # Prepare off resonance
        df = field_map + delta_cs

        # Divide-by-zero risk with PyTorch's nan_to_num
        E1 = torch.exp(-R1 * TR)
        E2 = torch.exp(-R2star * TE)
        Phi = torch.exp(1j * df * TE)

        # Precompute cos, sin
        ca = torch.cos(alpha)
        sa = torch.sin(alpha)

        # Main calculation
        den = 1 - E1 * ca
        Mxy = M0 * ((1 - E1) * sa) / den

        # Add decay
        signal = Mxy * E2

        # Add additional phase factor for readout at TE.
        signal = signal * Phi

        return signal
